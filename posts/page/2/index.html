<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>wb的博客 </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.62.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="wb的博客" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="wb的博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://qiujia236.github.io/posts/" />
<meta property="og:updated_time" content="2020-02-09T15:08:24+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://qiujia236.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      wb的博客
    </a>
    <div class="flex-l items-center">
      

      
      












    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/%E5%B8%B8%E8%A7%81%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/" class="link black dim">
        常见的HTTP状态码
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      常见的 HTTP 状态码 最基本的响应代码  200 - 请求成功 301 - 资源（网页等）被永久转移到其它 URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误  HTTP 状态码分类 HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：
  1** 系列响应代码仅在与 HTTP 服务器沟通时使用。
 100(&ldquo;Continue&rdquo;),该响应代码表明：客户端应重新发送初始请求，并在请求中附上第一次请求时未提供的（可能很大或者包含敏感信息的）表示。客户端这次发送的请求不会被拒绝。 101(&ldquo;Switching Protocols&rdquo;),当客户端通过在请求里使用 Upgrade 报头，以通知服务器它想改用除 HTTP 协议之外的其他协议时，客户端将获得此响应代码。101 响应代码表示“行，我现在改用另一个协议了”。通常 HTTP 客户端会在收到服务器发来的 101 响应后关闭与服务器的 TCP 连接。    2** 成功，操作被成功接收并处理。
 200(&ldquo;OK&rdquo;)，一般来说，这是客户端希望看到的响应代码。它表示服务器成功执行了客户端所请求的动作，对于 GET 请求，服务器应返回客户端所请求资源的一个表示。对于其他请求，服务器应返回当前所选资源的一个表示，或者刚刚执行的动作的一个描述。 201(&ldquo;Created&rdquo;)，当服务器依照客户端的请求创建了一个新资源时，发送此响应代码。Location 报头应包含指向新创建资源的规范 URI。 202(&ldquo;Accepted&rdquo;)，已接受。已经接受请求，但未处理完成。 204(&ldquo;No Content&rdquo;)，无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。    3** 重定向，需要进一步的操作以完成请求
 300(&ldquo;Multiple Choices&rdquo;),多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。 301(&ldquo;Moved Permanently&rdquo;)，永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。 303(&ldquo;See Other&rdquo;)，请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的 URI。该响应文档可能是一个静态的状态信息，也可能是一个更有趣的资源。 304(&ldquo;Not Modified&rdquo;)，未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。 307(&ldquo;Temporary Redirect&rdquo;)，临时重定向。当服务器希望把客户端重新定向到一个镜像站点时，可以用 307 来响应 GET 请求。对 POST，PUT 或者 DELETE 请求响应 303 表明：操作已经成功执行，但响应实体将不随本响应一起返回，若客户端想要获取响应实体主体，它需要向另一个 URI 发送 GET 请求。    ** 客户端错误，请求包含语法错误或无法完成请求。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/callapplybind%E7%9A%84%E7%94%A8%E6%B3%95/" class="link black dim">
        Call、apply、bind的用法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Call、apply、bind 的用法 this 的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把 this 固定下来，避免出现意想不到的情况。JavaScript 提供了 call、apply、bind 这三个方法，来切换/固定 this 的指向。
call 函数实例的 call 方法，可以指定函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。
var obj = {}; var f = function () { return this; }; f() === window // true f.call(obj) === obj // true 上面代码中，全局环境运行函数 f 时，this 指向全局环境（浏览器为 window 对象）；call 方法可以改变 this 的指向，指定 this 指向对象 obj，然后在对象 obj 的作用域中运行函数 f。
call 方法的参数，应该是一个对象。如果参数为空、null 和 undefined，则默认传入全局对象。
var n = 123; var obj = { n: 456 }; function a() { console.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/%E9%97%AD%E5%8C%85/" class="link black dim">
        闭包
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      闭包 闭包的概念 各种专业文献上的&quot;闭包&rdquo;（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。函数和函数内部能访问到的变量也叫环境的总和，组成一个闭包。
闭包的作用   可以读取函数内部的变量。
  一个就是让这些变量的值始终保持在内存中。
function foo() { var a = 2; return function fun1() { console.log(a) } } var fun2 = foo() fun2() //2 在上面的例子中，fun1 能够访问 foo 的内部作用域。在 foo()执行后，把 foo()的返回值 fun1 赋值给 fun2 并调用 fun2。打印出了结果 2 。
此时，我们可以说 fun1 记住并访问了所在的词法作用域 或者说 fun2 访问了另一个函数作用域中的变量。
由于引擎有自动的垃圾回收机制，在 foo()执行后（不再使用），通常 foo 的整个内部作用域会被销毁，对内存进行回收。闭包的神奇之处正是可以阻止这件事情的发生，因为 fun1 依然持有对该作用域的引用，这个引用就叫做闭包。
  闭包可以用来隐藏一个变量，比如有一个变量，我们不想别人直接访问它，而是间接使用你提供的方法来操作它，就可以使用闭包。
function outerFn(){ var i = 10; window.add = function(){ i+=1; } return i } var inner = outerFn(); inner(); //10 add(); inner(); //11   使用闭包的注意点   由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/jquery%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/" class="link black dim">
        JQuery的常用功能
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JQuery 的常用功能 概述 jQuery 是目前使用最广泛的 javascript 函数库。全世界排名前 100 万的网站，有 46%使用 jQuery，远远超过其他库。微软公司甚至把 jQuery 作为他们的官方库。 对于网页开发者来说，学会 jQuery 是必要的。因为它让你了解业界最通用的技术，为将来学习更高级的库打下基础，并且确实可以很轻松地做出许多复杂的效果。虽然 jQuery 上手简单，比其他库容易学会，但是要全面掌握，却不轻松。因为它涉及到网页开发的方方面面，提供的各种方法和内部变化有上千种之多。初学者常常感到，入门很方便，提高很困难。
jQuery 如何获取元素 jQuery 的基本设计思想和主要用法，就是&quot;选择某个网页元素，然后对其进行某种操作&rdquo;。这是它区别于其他 Javascript 库的根本特点。
使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为$），然后得到被选中的元素。
选择表达式可以是 CSS 选择器：
$(document) //选择整个文档对象  $(&#39;#myId&#39;) //选择ID为myId的网页元素  $(&#39;div.myClass&#39;) // 选择class为myClass的div元素  $(&#39;input[name=first]&#39;) // 选择name属性等于first的input元素 也可以是 jQuery 特有的表达式：
$(&#39;a:first&#39;) //选择网页中第一个a元素  $(&#39;tr:odd&#39;) //选择表格的奇数行  $(&#39;#myForm :input&#39;) // 选择表单中的input元素  $(&#39;div:visible&#39;) //选择可见的div元素 jQuery 设计思想之二，就是提供各种强大的过滤器，对结果集进行筛选，缩小选择结果。
$(&#39;div&#39;).has(&#39;p&#39;); // 选择包含p元素的div元素  $(&#39;div&#39;).not(&#39;.myClass&#39;); //选择class不等于myClass的div元素  $(&#39;div&#39;).filter(&#39;.myClass&#39;); //选择class等于myClass的div元素  $(&#39;div&#39;).
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/" class="link black dim">
        JS函数的执行时机
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS 函数的执行时机 setTimeout()基础 setTimeout 函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。
var timerId = setTimeout(func|code, delay) 上面代码中，setTimeout 函数接受两个参数，第一个参数 func|code 是将要推迟执行的函数名或者一段代码，第二个参数 delay 是推迟执行的毫秒数。
需要注意的是，推迟执行的代码必须以字符串的形式，放入 setTimeout，因为引擎内部使用 eval 函数，将字符串转为代码。如果推迟执行的是函数，则可以直接将函数名，放入 setTimeout。一方面 eval 函数有安全顾虑，另一方面为了便于 JavaScript 引擎优化代码，setTimeout 方法一般总是采用函数名的形式，就像下面这样。
function func(){ console.log(2); } setTimeout(func,1000); // 或者 setTimeout(function (){console.log(2)},1000); 分析 for 循环中的 setTimeout 函数 let i = 0 for(i = 0; i&lt;6; i++){ setTimeout(()=&gt;{ console.log(i) },3000) } 说起事件循环，不得不提起任务队列。事件循环只有一个，但任务队列可能有多个，任务队列可分为宏任务（macro-task）和微任务（micro-task）。注意进入到任务队列的是具体的执行任务的函数。比如上述例子 setTimeout()中的 console.log 函数。
XHR 回调、事件回调（鼠标键盘事件）、setImmediate、setTimeout、setInterval、indexedDB 数据库操作等 I/O 以及 UI rendering 都属于宏任务（也有文章说 UI render 不属于宏任务，目前还没有定论），process.nextTick、Promise.then、Object.observer(已经被废弃)、MutationObserver(html5 新特性)属于微任务。
另外不同类型的任务会分别进入到他们所属类型的任务队列，比如所有 setTimeout()的回调都会进入到 setTimeout 任务队列，所有 then()回调都会进入到 then 队列。当前的整体代码我们可以认为是宏任务。事件循环从当前整体代码开始第一次事件循环，然后再执行队列中所有的微任务，当微任务执行完毕之后，事件循环再找到其中一个宏任务队列并执行其中的所有任务，然后再找到一个微任务队列并执行里面的所有任务，就这样一直循环下去。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="link black dim">
        JS对象基本用法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JS 对象基本用法 概述 对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。
var obj = { foo: &#39;Hello&#39;, bar: &#39;World&#39; }; 上面代码中，大括号就定义了一个对象，它被赋值给变量 obj，所以变量 obj 就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是 foo: &lsquo;Hello&rsquo;，其中 foo 是“键名”（成员的名称），字符串 Hello 是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是 bar: &lsquo;World&rsquo;，bar 是键名，World 是键值。两个键值对之间用逗号分隔。
对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。
var obj = { &#39;foo&#39;: &#39;Hello&#39;, &#39;bar&#39;: &#39;World&#39; }; 如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。
// 报错 var obj = { 1p: &#39;Hello World&#39; }; // 不报错 var obj = { &#39;1p&#39;: &#39;Hello World&#39;, &#39;h w&#39;: &#39;Hello World&#39;, &#39;p+q&#39;: &#39;Hello World&#39; }; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/javascript%E8%AF%AD%E6%B3%95/" class="link black dim">
        JavaScript语法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JavaScript 语法 语句 JavaScript 程序的执行单位为行（line），也就是一行一行地执行。语句（statement）是为了完成某种任务而进行的操作。
var a = 1 + 2; 这条语句先用 var 命令，声明了变量 a，然后将 1 + 3 的运算结果赋值给变量 a。1 + 3 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。
语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
var a = 1 + 2 ; var b = &#34;a&#34;; 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。
1 + 3; &#39;abc&#39;; 变量   变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。
var a = 1; 上面的代码先声明变量 a，然后在变量 a 与数值 1 之间建立引用关系，称为将数值 1“赋值”给变量 a。以后，引用变量名 a 就会得到数值 1。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。
var a; a = 1; 如果只是声明变量而没有赋值，则该变量的值是 undefined。undefined 是一个特殊的值，表示“无定义”。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/javascript/" class="link black dim">
        JavaScript
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JavaScript 的诞生 诞生背景 &ldquo;1994 年，网景公司（Netscape）发布了 Navigator 浏览器 0.9 版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。&hellip;&hellip;网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。&rdquo; 网页脚本语言到底是什么语言？网景公司当时有两个选择：一个是采用现有的语言，比如 Perl、Python、Tcl、Scheme 等等，允许它们直接嵌入网页；另一个是发明一种全新的语言。
这两个选择各有利弊。第一个选择，有利于充分利用现有代码和程序员资源，推广起来比较容易；第二个选择，有利于开发出完全适用的语言，实现起来比较容易。
就在这时，发生了另外一件大事：1995 年 Sun 公司将 Oak 语言改名为 Java，正式向市场推出。
Sun 公司大肆宣传，许诺这种语言可以&quot;一次编写，到处运行&rdquo;（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。
网景公司动了心，决定与 Sun 公司结成联盟。它不仅允许 Java 程序以 applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将 Java 作为脚本语言嵌入网页，只是因为这样会使 HTML 网页过于复杂，后来才不得不放弃。
Brendan Eich 此时，34 岁的系统程序员 Brendan Eich 登场了。1995 年 4 月，网景公司录用了他。Brendan Eich 的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将 Scheme 语言作为网页脚本语言的可能性。
仅仅一个月之后，1995 年 5 月，网景公司做出决策，未来的网页脚本语言必须&quot;看上去与 Java 足够相似&rdquo;，但是比 Java 简单，使得非专业的网页作者也能很快上手。这个决策实际上将 Perl、Python、Tcl、Scheme 等非面向对象编程的语言都排除在外了。Brendan Eich 被指定为这种&quot;简化版 Java 语言&quot;的设计师。
但是，他对 Java 一点兴趣也没有。为了应付公司安排的任务，他只用 10 天时间就把 Javascript 设计出来了。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/%E6%B5%85%E6%9E%90url/" class="link black dim">
        浅析URL
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅析 URL URL 概述 URL 是 Web 中的一个核心概念。它是浏览器用来检索 web 上公布的任何资源的机制。
URL 指的是统一资源定位符（Uniform Resource Locator）。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个独特的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。
一个 URL 由不同的部分组成，其中一些是必须的，而另一些是可选的。让我们以下面这个 URL 为例看看其中最重要的部分：
http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocumenthttp:// 是协议。它表明了浏览器必须使用何种协议。它通常都是 HTTP 协议或是 HTTP 协议的安全版，即 HTTPS。Web 需要它们二者之一，但浏览器也知道如何处理其他协议，比如 mailto:（打开邮件客户端）或者 ftp:（处理文件传输），所以当你看到这些协议时，不必惊讶。
www.example.com 是域名。 它表明正在请求哪个 Web 服务器。或者，可以直接使用 IP address, 但是因为它不太方便，所以它不经常在网络上使用。
:80 是端口。 它表示用于访问 Web 服务器上的资源的技术“门”。如果 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。
/path/to/myfile.html 是网络服务器上资源的路径。在 Web 的早期阶段，像这样的路径表示 Web 服务器上的物理文件位置。
?key1=value1&amp;key2=value2 是提供给网络服务器的额外参数。 这些参数是用 &amp; 符号分隔的键/值对列表。在返回资源之前，Web 服务器可以使用这些参数来执行额外的操作。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://qiujia236.github.io/posts/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" class="link black dim">
        css知识总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浏览器渲染与动画 浏览器的渲染原理   浏览器工作大流程  根据 HTML 构建 HTL 树(DOM)； 根据 CSS 构建 CSS(CSSOM)； 将两棵树合并成一颗渲染树(rendertree)； Layout 布局（文档流、盒模型、计算大小和位置）； Paint 绘制（把边框颜色、文字颜色、阴影等画出来）； Compose 合成（根据层叠关系展示画面）。  浏览器会解析三个东西：
 HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。 CSS，解析 CSS 会产生 CSS 规则树。 Javascript，脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。  解析完成后，浏览器引擎会通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：
 Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。 CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering Tree 上的每个 Element。也就是 DOM 结点。也就是所谓的 Frame。 计算每个 Frame（也就是每个 Element）的位置，这又叫 layout 和 reflow 过程。  最后通过调用操作系统 Native GUI 的 API 绘制。
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/posts/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/3/">3</a></li>
    
    
    <li class="page-item">
    <a href="/posts/page/3/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/posts/page/3/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://qiujia236.github.io/" >
    &copy; 2020 wb的博客
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
