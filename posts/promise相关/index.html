<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>wb的博客  | Promise相关</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.62.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Promise相关" />
<meta property="og:description" content="Promise 相关 概述 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise 对象有以下两个特点。
 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。  有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。
// 传统写法 step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // ...  }); }); }); }); // Promise 的写法 (new Promise(step1)) .then(step2) .then(step3) .then(step4); 从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的 Promise 实例的生成格式，做了简化，真正的语法请参照下文。
基本用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
new Promise(function(resolve, reject) =&gt; {}); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qiujia236.github.io/posts/promise%E7%9B%B8%E5%85%B3/" />
<meta property="article:published_time" content="2020-02-02T15:15:12+08:00" />
<meta property="article:modified_time" content="2020-02-02T15:15:12+08:00" />
<meta itemprop="name" content="Promise相关">
<meta itemprop="description" content="Promise 相关 概述 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise 对象有以下两个特点。
 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。  有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。
// 传统写法 step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // ...  }); }); }); }); // Promise 的写法 (new Promise(step1)) .then(step2) .then(step3) .then(step4); 从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的 Promise 实例的生成格式，做了简化，真正的语法请参照下文。
基本用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
new Promise(function(resolve, reject) =&gt; {}); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。">
<meta itemprop="datePublished" content="2020-02-02T15:15:12&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-02T15:15:12&#43;08:00" />
<meta itemprop="wordCount" content="565">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Promise相关"/>
<meta name="twitter:description" content="Promise 相关 概述 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise 对象有以下两个特点。
 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。  有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。
// 传统写法 step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // ...  }); }); }); }); // Promise 的写法 (new Promise(step1)) .then(step2) .then(step3) .then(step4); 从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的 Promise 实例的生成格式，做了简化，真正的语法请参照下文。
基本用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
new Promise(function(resolve, reject) =&gt; {}); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://qiujia236.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      wb的博客
    </a>
    <div class="flex-l items-center">
      

      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Promise相关</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-02-02T15:15:12&#43;08:00">February 2, 2020</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id="promise-">Promise 相关</h1>
<h2 id="heading">概述</h2>
<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise 对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。</li>
</ol>
<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#75715e">// 传统写法
</span><span style="color:#75715e"></span><span style="color:#a6e22e">step1</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">value1</span>) {
  <span style="color:#a6e22e">step2</span>(<span style="color:#a6e22e">value1</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value2</span>) {
    <span style="color:#a6e22e">step3</span>(<span style="color:#a6e22e">value2</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value3</span>) {
      <span style="color:#a6e22e">step4</span>(<span style="color:#a6e22e">value3</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value4</span>) {
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>      });
    });
  });
});

<span style="color:#75715e">// Promise 的写法
</span><span style="color:#75715e"></span>(<span style="color:#66d9ef">new</span> Promise(<span style="color:#a6e22e">step1</span>))
  .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">step2</span>)
  .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">step3</span>)
  .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">step4</span>);
</code></pre></div><p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的 Promise 实例的生成格式，做了简化，真正的语法请参照下文。</p>
<h2 id="heading-1">基本用法</h2>
<p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {});
</code></pre></div><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">timeout</span>(<span style="color:#a6e22e">ms</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">ms</span>, <span style="color:#e6db74">&#39;done&#39;</span>);
  });
}

<span style="color:#a6e22e">timeout</span>(<span style="color:#ae81ff">100</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
});
</code></pre></div><h2 id="promiseprototypethen">Promise.prototype.then</h2>
<p>Promise 实例具有 then 方法，也就是说，then 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。</p>
<p>then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#a6e22e">getJSON</span>(<span style="color:#e6db74">&#34;/post/1.json&#34;</span>).<span style="color:#a6e22e">then</span>(
  <span style="color:#a6e22e">post</span> =&gt; <span style="color:#a6e22e">getJSON</span>(<span style="color:#a6e22e">post</span>.<span style="color:#a6e22e">commentURL</span>)
).<span style="color:#a6e22e">then</span>(
  <span style="color:#a6e22e">comments</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;resolved: &#34;</span>, <span style="color:#a6e22e">comments</span>),
  <span style="color:#a6e22e">err</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected: &#34;</span>, <span style="color:#a6e22e">err</span>)
);
</code></pre></div><p>第一个 then 方法指定的回调函数，返回的是另一个 Promise 对象。这时，第二个 then 方法指定的回调函数，就会等待这个新的 Promise 对象状态发生变化。如果变为 resolved，就调用第一个回调函数，如果状态变为 rejected，就调用第二个回调函数。</p>
<h2 id="promiseall">Promise.all()</h2>
<p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>, <span style="color:#a6e22e">p3</span>]);
</code></pre></div><p>p 的状态由 p1、p2、p3 决定，分成两种情况：</p>
<ol>
<li>
<p>只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
</li>
<li>
<p>只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">databasePromise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">connectDatabase</span>();

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">booksPromise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">databasePromise</span>
  .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">findAllBooks</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">userPromise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">databasePromise</span>
  .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">getCurrentUser</span>);

Promise.<span style="color:#a6e22e">all</span>([
  <span style="color:#a6e22e">booksPromise</span>,
  <span style="color:#a6e22e">userPromise</span>
])
.<span style="color:#a6e22e">then</span>(([<span style="color:#a6e22e">books</span>, <span style="color:#a6e22e">user</span>]) =&gt; <span style="color:#a6e22e">pickTopRecommendations</span>(<span style="color:#a6e22e">books</span>, <span style="color:#a6e22e">user</span>));
</code></pre></div><p>上面代码中，booksPromise 和 userPromise 是两个异步操作，只有等到它们的结果都返回了，才会触发 pickTopRecommendations 这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;hello&#39;</span>);
})
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">result</span>)
.<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">e</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;报错了&#39;</span>);
})
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">result</span>)
.<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">e</span>);

Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>])
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>))
.<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>));
<span style="color:#75715e">// [&#34;hello&#34;, Error: 报错了]
</span></code></pre></div><p>上面代码中，p1 会 resolved，p2 首先会 rejected，但是 p2 有自己的 catch 方法，该方法返回的是一个新的 Promise 实例，p2 指向的实际上是这个实例。该实例执行完 catch 方法后，也会变成 resolved，导致 Promise.all()方法参数里面的两个实例都会 resolved，因此会调用 then 方法指定的回调函数，而不会调用 catch 方法指定的回调函数。</p>
<p>如果 p2 没有自己的 catch 方法，就会调 Promise.all()的 catch 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;hello&#39;</span>);
})
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">result</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;报错了&#39;</span>);
})
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">result</span>);

Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>])
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>))
.<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>));
<span style="color:#75715e">// Error: 报错了
</span></code></pre></div><h2 id="promiserace">Promise.race()</h2>
<p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">race</span>([<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>, <span style="color:#a6e22e">p3</span>]);
</code></pre></div><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<p>Promise.race()方法的参数与 Promise.all()方法一样，如果不是 Promise 实例，就会先调用 Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为 reject，否则变为 resolve。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">race</span>([
  <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;/resource-that-may-take-a-while&#39;</span>),
  <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
    <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;request timeout&#39;</span>)), <span style="color:#ae81ff">5000</span>)
  })
]);

<span style="color:#a6e22e">p</span>
.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>)
.<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>);
</code></pre></div><p>上面代码中，如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数。</p>
<h2 id="promiseresolve">Promise.resolve()</h2>
<p>有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">jsPromise</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">ajax</span>(<span style="color:#e6db74">&#39;/whatever.json&#39;</span>));
</code></pre></div><p>上面代码将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象。</p>
<p>Promise.resolve()等价于下面的写法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript">Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;foo&#39;</span>)
<span style="color:#75715e">// 等价于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> Promise(<span style="color:#a6e22e">resolve</span> =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;foo&#39;</span>))
</code></pre></div><p>Promise.resolve 方法的参数分成四种情况。</p>
<ol>
<li>
<p>如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。</p>
</li>
<li>
<p>参数是一个 thenable 对象，thenable 对象指的是具有 then 方法的对象，比如下面这个对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thenable</span> <span style="color:#f92672">=</span> {
 <span style="color:#a6e22e">then</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
     <span style="color:#a6e22e">resolve</span>(<span style="color:#ae81ff">42</span>);
 }
};

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">thenable</span>);
 <span style="color:#a6e22e">p1</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value</span>) {
 <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);  <span style="color:#75715e">// 42
</span><span style="color:#75715e"></span>});
</code></pre></div><p>Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。上面代码中，thenable 对象的 then 方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后那个 then 方法指定的回调函数，输出 42。</p>
</li>
<li>
<p>参数不是具有 then 方法的对象，或根本就不是对象，如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;Hello&#39;</span>);

<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">s</span>){
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">s</span>)
});
<span style="color:#75715e">// Hello
</span></code></pre></div><p>上面代码生成一个新的 Promise 对象的实例 p。由于字符串 Hello 不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是 resolved，所以回调函数会立即执行。Promise.resolve 方法的参数，会同时传给回调函数。</p>
</li>
<li>
<p>Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用 Promise.resolve()方法。</p>
<p>需要注意的是，立即 resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;three&#39;</span>);
}, <span style="color:#ae81ff">0</span>);

Promise.<span style="color:#a6e22e">resolve</span>().<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;two&#39;</span>);
});

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;one&#39;</span>);

<span style="color:#75715e">// one
</span><span style="color:#75715e"></span><span style="color:#75715e">// two
</span><span style="color:#75715e"></span><span style="color:#75715e">// three
</span></code></pre></div><p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&lsquo;one&rsquo;)则是立即执行，因此最先输出。</p>
</li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://qiujia236.github.io/" >
    &copy; 2020 wb的博客
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
