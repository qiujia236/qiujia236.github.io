<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>wb的博客  | Call、apply、bind的用法</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.62.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Call、apply、bind的用法" />
<meta property="og:description" content="Call、apply、bind 的用法 this 的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把 this 固定下来，避免出现意想不到的情况。JavaScript 提供了 call、apply、bind 这三个方法，来切换/固定 this 的指向。
call 函数实例的 call 方法，可以指定函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。
var obj = {}; var f = function () { return this; }; f() === window // true f.call(obj) === obj // true 上面代码中，全局环境运行函数 f 时，this 指向全局环境（浏览器为 window 对象）；call 方法可以改变 this 的指向，指定 this 指向对象 obj，然后在对象 obj 的作用域中运行函数 f。
call 方法的参数，应该是一个对象。如果参数为空、null 和 undefined，则默认传入全局对象。
var n = 123; var obj = { n: 456 }; function a() { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qiujia236.github.io/posts/callapplybind%E7%9A%84%E7%94%A8%E6%B3%95/" />
<meta property="article:published_time" content="2020-02-01T20:46:21+08:00" />
<meta property="article:modified_time" content="2020-02-01T20:46:21+08:00" />
<meta itemprop="name" content="Call、apply、bind的用法">
<meta itemprop="description" content="Call、apply、bind 的用法 this 的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把 this 固定下来，避免出现意想不到的情况。JavaScript 提供了 call、apply、bind 这三个方法，来切换/固定 this 的指向。
call 函数实例的 call 方法，可以指定函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。
var obj = {}; var f = function () { return this; }; f() === window // true f.call(obj) === obj // true 上面代码中，全局环境运行函数 f 时，this 指向全局环境（浏览器为 window 对象）；call 方法可以改变 this 的指向，指定 this 指向对象 obj，然后在对象 obj 的作用域中运行函数 f。
call 方法的参数，应该是一个对象。如果参数为空、null 和 undefined，则默认传入全局对象。
var n = 123; var obj = { n: 456 }; function a() { console.">
<meta itemprop="datePublished" content="2020-02-01T20:46:21&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-01T20:46:21&#43;08:00" />
<meta itemprop="wordCount" content="639">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Call、apply、bind的用法"/>
<meta name="twitter:description" content="Call、apply、bind 的用法 this 的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把 this 固定下来，避免出现意想不到的情况。JavaScript 提供了 call、apply、bind 这三个方法，来切换/固定 this 的指向。
call 函数实例的 call 方法，可以指定函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。
var obj = {}; var f = function () { return this; }; f() === window // true f.call(obj) === obj // true 上面代码中，全局环境运行函数 f 时，this 指向全局环境（浏览器为 window 对象）；call 方法可以改变 this 的指向，指定 this 指向对象 obj，然后在对象 obj 的作用域中运行函数 f。
call 方法的参数，应该是一个对象。如果参数为空、null 和 undefined，则默认传入全局对象。
var n = 123; var obj = { n: 456 }; function a() { console."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://qiujia236.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      wb的博客
    </a>
    <div class="flex-l items-center">
      

      
      












    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Call、apply、bind的用法</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-02-01T20:46:21&#43;08:00">February 1, 2020</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id="callapplybind-">Call、apply、bind 的用法</h1>
<p>this 的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把 this 固定下来，避免出现意想不到的情况。JavaScript 提供了 call、apply、bind 这三个方法，来切换/固定 this 的指向。</p>
<h2 id="call">call</h2>
<p>函数实例的 call 方法，可以指定函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>;
};

<span style="color:#a6e22e">f</span>() <span style="color:#f92672">===</span> window <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">obj</span>) <span style="color:#f92672">===</span> <span style="color:#a6e22e">obj</span> <span style="color:#75715e">// true
</span></code></pre></div><p>上面代码中，全局环境运行函数 f 时，this 指向全局环境（浏览器为 window 对象）；call 方法可以改变 this 的指向，指定 this 指向对象 obj，然后在对象 obj 的作用域中运行函数 f。</p>
<p>call 方法的参数，应该是一个对象。如果参数为空、null 和 undefined，则默认传入全局对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">n</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">456</span> };

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">a</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">n</span>);
}

<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">call</span>() <span style="color:#75715e">// 123
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">null</span>) <span style="color:#75715e">// 123
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">undefined</span>) <span style="color:#75715e">// 123
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">call</span>(window) <span style="color:#75715e">// 123
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">obj</span>) <span style="color:#75715e">// 456
</span></code></pre></div><p>上面代码中，a 函数中的 this 关键字，如果指向全局对象，返回结果为 123。如果使用 call 方法将 this 关键字指向 obj 对象，返回结果为 456。可以看到，如果 call 方法没有参数，或者参数为 null 或 undefined，则等同于指向全局对象。</p>
<p>如果 call 方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入 call 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>;
};

<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">call</span>(<span style="color:#ae81ff">5</span>)
<span style="color:#75715e">// Number {[[PrimitiveValue]]: 5}
</span></code></pre></div><p>上面代码中，call 的参数为 5，不是对象，会被自动转成包装对象（Number 的实例），绑定 f 内部的 this。</p>
<p>call 方法还可以接受多个参数。call 的第一个参数就是 this 所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
}

<span style="color:#a6e22e">add</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>) <span style="color:#75715e">// 3
</span></code></pre></div><p>上面代码中，call 方法指定函数 add 内部的 this 绑定当前环境（对象），并且参数为 1 和 2，因此函数 add 运行后得到 3。</p>
<p>call 方法的一个应用是调用对象的原生方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {};
<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;toString&#39;</span>) <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 覆盖掉继承的 hasOwnProperty 方法
</span><span style="color:#75715e"></span><span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">hasOwnProperty</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
};
<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;toString&#39;</span>) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
Object.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">hasOwnProperty</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">obj</span>, <span style="color:#e6db74">&#39;toString&#39;</span>) <span style="color:#75715e">// false
</span></code></pre></div><p>上面代码中，hasOwnProperty 是 obj 对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call 方法可以解决这个问题，它将 hasOwnProperty 方法的原始定义放到 obj 对象上执行，这样无论 obj 上有没有同名方法，都不会影响结果。</p>
<h2 id="apply">apply()</h2>
<p>apply 方法的作用与 call 方法类似，也是改变 this 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<pre><code>func.apply(thisValue, [arg1, arg2, ...])
</code></pre><p>apply 方法的第一个参数也是 this 所要指向的那个对象，如果设为 null 或 undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在 call 方法中必须一个个添加，但是在 apply 方法中，必须以数组形式添加。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>){
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>);
}

<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">null</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">null</span>, [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]) <span style="color:#75715e">// 2```
</span></code></pre></div><ol>
<li>
<p>找出数组最大元素，JavaScript 不提供找出数组最大元素的函数。结合使用 apply 方法和 Math.max 方法，就可以返回数组的最大元素。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">9</span>];
Math.<span style="color:#a6e22e">max</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">null</span>, <span style="color:#a6e22e">a</span>) <span style="color:#75715e">// 15
</span></code></pre></div></li>
<li>
<p>转换类似数组的对象,利用数组对象的 slice 方法，可以将一个类似数组的对象（比如 arguments 对象）转为真正的数组。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript">Array.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">slice</span>.<span style="color:#a6e22e">apply</span>({<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">length</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}) <span style="color:#75715e">// [1]
</span><span style="color:#75715e"></span>Array.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">slice</span>.<span style="color:#a6e22e">apply</span>({<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}) <span style="color:#75715e">// []
</span><span style="color:#75715e"></span>Array.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">slice</span>.<span style="color:#a6e22e">apply</span>({<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">length</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>}) <span style="color:#75715e">// [1, undefined]
</span><span style="color:#75715e"></span>Array.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">slice</span>.<span style="color:#a6e22e">apply</span>({<span style="color:#a6e22e">length</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>}) <span style="color:#75715e">// [undefined]
</span></code></pre></div><p>上面代码的 apply 方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有 length 属性，以及相对应的数字键。</p>
</li>
<li>
<p>绑定回调函数的对象</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();

 <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
 <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>);
 }

 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (){
 <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">o</span>);
 <span style="color:#75715e">// 或者 o.f.call(o);
</span><span style="color:#75715e"></span> };

 <span style="color:#75715e">// jQuery 的写法
</span><span style="color:#75715e"></span> <span style="color:#960050;background-color:#1e0010">\</span><span style="color:#a6e22e">$</span>(<span style="color:#e6db74">&#39;#button&#39;</span>).<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;click&#39;</span>, <span style="color:#a6e22e">f</span>);
</code></pre></div><p>上面代码中，点击按钮以后，控制台将会显示 true。由于 apply 方法（或者 call 方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的 bind 方法。</p>
</li>
</ol>
<h2 id="bind">bind()</h2>
<p>bind 方法用于将函数体内的 this 绑定到某个对象，然后返回一个新函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">count</span><span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
  <span style="color:#a6e22e">inc</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>;
  }
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">func</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">inc</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">counter</span>);
<span style="color:#a6e22e">func</span>();
<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">count</span> <span style="color:#75715e">// 1
</span></code></pre></div><p>上面代码中，counter.inc 方法被赋值给变量 func。这时必须用 bind 方法将 inc 内部的 this，绑定到 counter，否则就会出错。</p>
<p>this 绑定到其他对象也是可以的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">count</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
  <span style="color:#a6e22e">inc</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>;
  }
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">count</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">100</span>
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">func</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">inc</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">obj</span>);
<span style="color:#a6e22e">func</span>();
<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">count</span> <span style="color:#75715e">// 101
</span></code></pre></div><p>上面代码中，bind 方法将 inc 方法内部的 this，绑定到 obj 对象。结果调用 func 函数以后，递增的就是 obj 内部的 count 属性。</p>
<p>bind 还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">m</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">n</span>;
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">m</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
  <span style="color:#a6e22e">n</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">newAdd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">add</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">obj</span>, <span style="color:#ae81ff">5</span>);
<span style="color:#a6e22e">newAdd</span>(<span style="color:#ae81ff">5</span>) <span style="color:#75715e">// 20
</span></code></pre></div><p>上面代码中，bind 方法除了绑定 this 对象，还将 add 函数的第一个参数 x 绑定成 5，然后返回一个新函数 newAdd，这个函数只要再接受一个参数 y 就能运行了。</p>
<p>如果 bind 方法的第一个参数是 null 或 undefined，等于将 this 绑定到全局对象，函数运行时 this 指向顶层对象（浏览器为 window）。</p>
<p>bind 方法有一些使用注意点。</p>
<ol>
<li>
<p>每一次返回一个新函数，bind 方法每运行一次，就返回一个新函数，这会产生一些问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
   <span style="color:#a6e22e">init</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
   <span style="color:#a6e22e">add</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
       <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">init</span>;
   }
 }
 <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">plus</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">add</span>;
 <span style="color:#a6e22e">plus</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>); <span style="color:#75715e">// NaN，因为 this.init 不存在，这里的 this 指向 window/global
</span><span style="color:#75715e"></span>
 <span style="color:#a6e22e">plus</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">obj</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>) <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">plus</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">obj</span>, [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]); <span style="color:#75715e">// 8， apply 和 call 的区别就是第二个参数为数组
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">plus</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">obj</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>); <span style="color:#75715e">// 返回一个函数，这里就是 bind 和 call/apply 的区别之一，bind 的时候不会立即执行
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">plus</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">obj</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)(); <span style="color:#75715e">// 8
</span></code></pre></div></li>
<li>
<p>结合回调函数使用，回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含 this 的方法直接当作回调函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">count</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
  <span style="color:#a6e22e">inc</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
    <span style="color:#e6db74">&#39;use strict&#39;</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>;
  }
};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">callIt</span>(<span style="color:#a6e22e">callback</span>) {
  <span style="color:#a6e22e">callback</span>();
}

<span style="color:#a6e22e">callIt</span>(<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">inc</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">counter</span>));
<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">count</span> <span style="color:#75715e">// 1
</span></code></pre></div><p>上面代码中，callIt 方法会调用回调函数。这时如果直接把 counter.inc 传入，调用时 counter.inc 内部的 this 就会指向全局对象。使用 bind 方法将 counter.inc 绑定 counter 以后，就不会有这个问题，this 总是指向 counter。</p>
</li>
<li>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的 this 指向，很可能也会出错。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;张三&#39;</span>,
  <span style="color:#a6e22e">times</span><span style="color:#f92672">:</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>],
  <span style="color:#a6e22e">print</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">times</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">n</span>) {
      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
    });
  }
};

<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">print</span>()
<span style="color:#75715e">// 没有任何输出
</span></code></pre></div><p>上面代码中，obj.print 内部 this.times 的 this 是指向 obj 的，这个没有问题。但是，forEach 方法的回调函数内部的 this.name 却是指向全局对象。解决这个问题，也是通过 bind 方法绑定 this。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JavaScript" data-lang="JavaScript"><span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">print</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">times</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">n</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
  }.<span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">this</span>));
};

<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">print</span>()
<span style="color:#75715e">// 张三
</span><span style="color:#75715e"></span><span style="color:#75715e">// 张三
</span><span style="color:#75715e"></span><span style="color:#75715e">// 张三
</span></code></pre></div></li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://qiujia236.github.io/" >
    &copy; 2020 wb的博客
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
